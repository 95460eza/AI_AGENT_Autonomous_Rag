
# 3-STAGE image building TO MINIMIZE THE IMAGE SIZE!!!!!!!!


# SPECIFIES THAT AN ARGUMENT WILL BE PASSED VIA "PYTHON_DOCKER_IMAGE=" WHEN RUNNING THE "DOCKER BUILD" COMMAND
# docker build -t <repository>:<tag> <path> . "path" can be "," to mean current directory and repository can be just a name or a "REMOTE" REPOSITORY (Ex: AZURE CONTAINER REGISTRY INFO)
# Ex: docker build --build-arg PYTHON_DOCKER_IMAGE=python:3.9 -t image_webapp:latest .
# "-t" is for "tag" to name the image you're building (making it easier to refer to) 
# ALSO PROVIDING A "DEFAULT" VALUE

ARG PYTHON_DOCKER_IMAGE=python:3.12.9



# NOTE: EACH "FROM" COMMAND BELOW WILL START A NEW BUILD "STAGE" (AKA VERSION) OF THE IMAGE YOU CREATING.
# WE USE EACH STAGE TO INSTALL/BUILD DEVELOPMENT LIBRARIES (like compilers, gcc, git) THEN copy only the necessary artifacts (e.g., the virtual environment, compiled code, etc.) TO THE FINAL STAGE



# *****************************STAGE 0: START BY PULLING FROM DOCKER HUB AN OFFICIAL DOCKER IMAGE AND MAKE IT AVAILABLE VIA AN ALIAS FOR CONVIENENCE********************************
# DURING THE VARIOUS "BUILD" STAGES WE WIL REFER TO THIS DOCKER IMAGE THAT WAY (HERE REFERRING TO IMAGE "python:3.12.9")

FROM $PYTHON_DOCKER_IMAGE AS python-base



# *************************STAGE 1 CREATES A "TEMPORARY" IMAGE CALLED "python-builder" TO CONTAIN THE ELEMENTS WE NEED***********************************
# STAGE 1 (AKA DRAFT 1) - PART "A": WE ARE ONLY "PULLING" THE SPECIFIED "IMAGE" FROM DOCKER HUB REGISTRY. 
# OFFICIAL PYTHON IMAGES ARE "LINUX-BASED" UNLESS YOU SPECIFY (Ex: python:3.12.9-windowsservercore OR SIMILAR)
# THE IMAGE COMES WITH SOME FILES ALREADY INSTALLED IN ITS "ROOT" DIRECTORY AND AT THIS POINT EVERY "COMMAND" WE ARE WRITING "EXECUTES" IN THE "ROOT" OF THE IMAGE
# THE "AS" INSTRUCTION SIMPLY GIVES AN ALIAS FOR SIMPLICITY OF FUTURE REFERENCE TO THE IMAGE CREATED AT THIS STAGE

FROM python-base AS python-builder




# STAGE 1 (AKA DRAFT IMAGE 1) - PART "B": WE UPGRADE TO THEIR LATEST VERSION ANY "ALREADY" INSTALLED PACKAGES IN THE IMAGE 
# "apt-get" is a lower-level tool more stable for "SCRIPTING" WHILE "apt" is a higher-level for human (combining the functionality of apt-get, apt-cache, etc.) AND is NOT RECOMMENDE IN "SCRIPTS" 
# "gcc: IS The GNU Compiler Collection THAT installs the C/C++ compilers required for compiling many native packages.
# "apt-get clean" reduces the size of the Docker image by removing UNNECESSARY files no longer needed after installation.
# Install git and other dependencies

RUN apt-get update && \
    apt-get upgrade -y && \
    apt-get install -y git gcc && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*   # further reduce image size by removing cached package lists.



 
# STAGE 1 (AKA DRAFT IMAGE 1) - PART "C": CREATE INSIDE THE IMAGE (THE IMAGE IS LIKE A MINI STAND-ALONE COMPUTER) THE PYTHON VIRTUAL ENVIRONMENT WHERE THE LIBRARIES WILL BE INSTALLED
# IT IS "GOOD PRACTICE" TO KEEP THE "FILE" "STRUCTURE" IN THE "IMAGE" ORGANIZED. THUS, WE CREATE THE VIRTUAL ENVIRONMENT IN A DIRECTORY "SEPARATE" FROM THE "ROOT" OF THE IMAGE BY "FIRST" USING THE "WORKDIR" INSTRUCTION
# THIS ALSO AVOIDS POTENTIAL CONFLICT WITH OTHER FILES IN THE  "ROOT" OF THE IMAGE.
# NOTE 1: THE "WORKDIR" INSTRUCTION "DOES NOT" CARRY OVER ACROSS THE STAGES STARTED BY A "FROM" COMMAND (WE WILL THEN START BACK IN THE ROOT OF THE NEW IMAGE)!!!!!!!!!!!!!!!!!!!!
# WHEN THE "WORKDIR /app" INSTRUCTION IS SEEN, Docker AUTOMATICALLY CREATES "INSIDE THE IMAGE" THE "/app" FOLDER IF IT DOESN'T ALREADY EXIST!!!!
# NOTE 2: STARTING WITH A "/" "ALWAYS" SPECIFIES AN "ABSOLUTE" PATH RELATIVE TO THE "ROOT" OF THE IMAGE "REGARDLESS" OF WHERE WE ARE IN THE IMAGE
# THUS HERE THE "app" FOLDER IS CREATED DIRECTLY IN THE ROOT OF THE IMAGE 
# AFTER THIS "WORKDIR /app" COMMAND, EVERY "COMMAND" WE ARE WRITING "EXECUTES" IN THE "app" FOLDER OF THE IMAGE AND THEY ALSO "USE" FILES FROM THE "app" FOLDER 
# ANY COMMAND USING "RELATIVE" PATH WILL NOW BE RELATIVE TO "BEING" IN THE "app" FOLDER
# WE USE "ABSOLUTE" PATH TO CREATE THE VIRTUAL ENVIRONMENT BECAUSE THE PYTHON "VENV" MODULE DOES NOT RECOGNIZE RELATIVE PATHS!! 
# "VENV" CREATES THE FOLDER WHOSE NAME IS SPECIFIED (HERE ".env" FOLDER) AT THE "PATH" SPECIFIED (HERE INSIDE "app")

WORKDIR /app
RUN python -m venv /app/.venv



# STAGE 1 (AKA DRAFT IMAGE 1) - PART "D": COPY THE "REQUIREMENTS.TXT" FILE FROM OUR LOCAL COMPUTER INTO THE IMAGE
# NOTE 1: "." IN "./" MEANS THAT WE WILL BE SPECIFYING A "PATH" "RELATIVE" TO THE "FOLDER" WHERE WE ARE "NOW" 
# NOTE 2: GIVING A "FILE" NAME "DIRECTLY" AFTER THE "/" WITHOUT "ADDITIONAL" PATH INFORMATIONS MEANS WE ARE REFERRING TO A FILE IN "SAME" THE FOLDER WHERE ARE "NOW"
# THUS, "./requirements.txt" MEANS TO COPY "requirements.txt" FROM THE "FOLDER" ON OUR "LOCAL" COMPUTER TO WHICH THE "SHELL" IS "POINTING" "WHEN" WE RUN THE "DOCKER BUILD" COMMAND. USUALL WILL BE THE "FOLDER" CONTAINING THE 
# "DOCKERFILE"
# THE SECOND "./" MEANS THE "DESTINATION" OF THE "requirements.txt" FILE BEING "COPIED" IS THE "FOLDER" "INSIDE" THE "IMAGE" WHERE WE ARE EXECUTING BECAUSE "." MEANS "RELATIVE" TO WHERE WE ARE EXECUTING IN THE IMAGE (HERE INSIDE THE 
# "app" FOLDER BECAUSE OF "WORKDIR /app" ABOVE) AND THE "/" WITHOUT "ADDITIONAL" PATH INFORMATIONS MEANS WE "STAY" IN THAT FOLDER! 
  
COPY ./requirements.txt  ./



# STAGE 1 (AKA DRAFT IMAGE 1) - PART "E": SETTING UP AN "ENVIRONMENTAL" VARIABLE THAT WILL BE "ALWAYS" ACCESSIBLE STARTING ONLY FROM "NOW" ON!
# NORMALLY AFTER A VIRTUAL ENVIRONMENT IS "CREATED", IT MUST BE ACTIVATED BEFORE WE CAN ACCESS ITS LIBRARIES. 
# HERE WITH THE COMMAND "PATH=".venv/bin:$PATH" WE ASK THAT BINARIES (PYTHON EXECUTABLE CODE) IN THE ".env" VIRTUAL ENVIRONMENT BE PRIORITIZE  WITHOUT HAVING TO EXPLICITLY "ACTIVATE" THAT ENVIRONMENTOVER ANY OTHERS WHEN WE RUN PYTHON # COMMANDS. SET THIS "ENVIRONMENTAL" VARIABLE OBVIOUSLY "AFTER" THE VIRTUAL ENVIRONMENT IS "CREATED" BY "VENV" (SO IT EXISTS!) BUT "BEFORE" WE USE ITS LIBRARIES FOR THE FIRST TIME!

ENV PATH=".venv/bin:$PATH"



# STAGE 1 (AKA DRAFT IMAGE 1) - PART "F": INSTALLS THE LIBRARIES IN "requirements.txt" IN THE ".venv" VIRTUAL ENVIRONMENT SINCE WE ASKED ABOVE VIA THE "ENVIRONMENTAL" VARIABLE TO USE THE BINARIES FROM THAT VIRTUAL ENVIRONMENT 
# THIS INCLUDES ITS PYTHON INTERPRETER AND PIP EXECUTABLE
RUN pip install --upgrade pip

# "--no-cache-dir" TO AVOID KEEPING PIP DOWNLOADED "CACHES"
#RUN pip install -r requirements.txt

RUN pip install --no-cache-dir -r requirements.txt
RUN pip install gunicorn




# *************************STAGE 2 CREATES OUR "FINAL" IMAGE *********************************************************************************
# STAGE 2 (AKA FINAL IMAGE 2) - PART "A": START "FRESH" WITH THE OFFICIAL "IMAGE" "PULLED" FROM DOCKER HUB REGISTRY (ALIASED AS python-base)


FROM python-base



# STAGE 2 (AKA FINAL IMAGE 2) - PART "B": SPECIFY AGAIN THE "app" FOLDER AS OUR "WORKING" DIRECTORY
# IT IS CREATED SINCE IT DOES NOT EXIST IN THE FRESH IMAGE
# RECALL: THE "WORKDIR" INSTRUCTION "DOES NOT" CARRY OVER ACROSS THE STAGES STARTED BY A "FROM" COMMAND!!!!!!!!!!!!!!!!!!!!

WORKDIR /app



# STAGE 2 (AKA FINAL IMAGE 2) - PART "C": COPY THE VIRTUAL ENVIRONMENT CREATED IN THE PREVIOUS STAGE (INSIDE "python-builder") INTO OUR NEW IMAGE
# ONLY COPIES THE PYTHON PACKAGES "WITHOUT" THE BUILD DEPENDENCIES
COPY --from=python-builder /app/.venv ./.venv



# COPY "FROM" THE "LOCAL" MACHINE THE "CONTENT" APP FOLDER (FOUND RELATIVE TO DOCKERFILE "LOCATION") "INTO" THE APP FOLDER IN THE IMAGE (BECAUSE "WORKDIR /app" AND "./")

COPY ./app/ ./


# RE-SET THE PATH TO PRIORITIZE BY PYTHON FOR RUNNING BINARIES TO ".VENV" IN THE NEW IMAGE   

ENV PATH="/app/.venv/bin:$PATH"



# EXPOSE 7860
EXPOSE 5000


#gunicorn -w 4 -b 0.0.0.0:5000 app:app
ENTRYPOINT ["gunicorn", "-w", "4", "--bind", "0.0.0.0:5000", "app:app"]


# TO BUILD THE IMAGE AND RUN THE APPLICATION FROM WITHIN THE CONTAINER
#docker build --build-arg PYTHON_DOCKER_IMAGE=python:3.12.9-slim -f Dockerfile -t image-ai_agent_autonomous_reasoning_rag:latest .
#docker run  -p <host_port>:<container_port> my_appname:latest 
#docker run -p 8000:5000 -e HUGFACE_AUTH_TOKEN=<> -e MISTRAL_API_KEY=<> image-ai_agent_autonomous_reasoning_rag:latest

